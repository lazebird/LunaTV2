# LunaTV 文件系统存储方案设计

## 概述

本文档分析了在 LunaTV 当前架构下增加文件系统存储方案的可行性，并提供了详细的实现方案和接口设计。文件系统存储方案可以作为现有存储模式（localStorage、Redis、Upstash、KVRocks）的补充，提供一种轻量级、零配置的持久化存储选择。

## 可行性分析

### 当前架构优势

LunaTV 项目具有良好的存储抽象设计，为文件系统存储方案提供了良好的基础：

1. **统一存储接口** - `IStorage` 接口定义了标准的存储操作
2. **存储模式可配置** - 通过 `NEXT_PUBLIC_STORAGE_TYPE` 环境变量切换
3. **模块化设计** - 各存储实现独立，易于扩展
4. **数据结构标准化** - 所有数据都有明确的 TypeScript 类型定义

### 技术可行性

✅ **完全可行**，原因如下：

1. **Node.js 文件系统支持** - 项目运行在 Node.js 环境，原生支持文件操作
2. **JSON 序列化兼容** - 现有数据结构都可以序列化为 JSON
3. **异步操作支持** - Node.js fs/promises 提供异步文件操作
4. **错误处理机制** - 可以复用现有的错误处理逻辑

### 部署场景适配

文件系统存储方案特别适合以下部署场景：

- **VPS/云服务器部署** - 有持久化文件系统
- **Docker 容器部署** - 可通过卷映射持久化
- **本地开发环境** - 零配置，开箱即用
- **单机部署** - 无需外部依赖

## 实现方案设计

### 目录结构设计

```
data/
├── users/                    # 用户数据
│   ├── {username}/
│   │   ├── profile.json      # 用户基本信息
│   │   ├── playrecords.json  # 播放记录
│   │   ├── favorites.json    # 收藏夹
│   │   ├── searchhistory.json # 搜索历史
│   │   └── skipconfigs.json  # 跳过配置
├── cache/                    # 缓存数据
│   ├── tmdb/
│   ├── douban/
│   └── shortdrama/
├── config/                   # 配置数据
│   ├── admin.json           # 管理员配置
│   └── sites.json           # 站点配置
├── stats/                    # 统计数据
│   ├── playstats.json       # 播放统计
│   └── userstats/           # 用户统计
│       └── {username}.json
└── temp/                     # 临时文件
```

### 核心实现类

```typescript
// src/lib/file-system.db.ts
import { promises as fs } from 'fs';
import path from 'path';
import { IStorage, PlayRecord, Favorite, AdminConfig } from './types';

export class FileSystemStorage implements IStorage {
  private dataDir: string;
  private usersDir: string;
  private cacheDir: string;
  private configDir: string;
  private statsDir: string;

  constructor() {
    this.dataDir = process.env.FILE_SYSTEM_DATA_DIR || './data';
    this.usersDir = path.join(this.dataDir, 'users');
    this.cacheDir = path.join(this.dataDir, 'cache');
    this.configDir = path.join(this.dataDir, 'config');
    this.statsDir = path.join(this.dataDir, 'stats');
    
    this.initDirectories();
  }

  private async initDirectories(): Promise<void> {
    const dirs = [this.dataDir, this.usersDir, this.cacheDir, this.configDir, this.statsDir];
    await Promise.all(dirs.map(dir => fs.mkdir(dir, { recursive: true })));
  }

  private getUserDir(username: string): string {
    return path.join(this.usersDir, username);
  }

  private async ensureUserDir(username: string): Promise<void> {
    const userDir = this.getUserDir(username);
    await fs.mkdir(userDir, { recursive: true });
  }

  // 文件操作辅助方法
  private async readJsonFile<T>(filePath: string): Promise<T | null> {
    try {
      const data = await fs.readFile(filePath, 'utf-8');
      return JSON.parse(data);
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        return null;
      }
      throw error;
    }
  }

  private async writeJsonFile(filePath: string, data: any): Promise<void> {
    const dir = path.dirname(filePath);
    await fs.mkdir(dir, { recursive: true });
    await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');
  }

  // 实现 IStorage 接口...
}
```

### 数据存储策略

#### 1. 用户数据存储

```typescript
// 播放记录存储
async setPlayRecord(userName: string, key: string, record: PlayRecord): Promise<void> {
  await this.ensureUserDir(userName);
  const filePath = path.join(this.getUserDir(userName), 'playrecords.json');
  const records = await this.readJsonFile<Record<string, PlayRecord>>(filePath) || {};
  records[key] = record;
  await this.writeJsonFile(filePath, records);
}

// 收藏夹存储
async setFavorite(userName: string, key: string, favorite: Favorite): Promise<void> {
  await this.ensureUserDir(userName);
  const filePath = path.join(this.getUserDir(userName), 'favorites.json');
  const favorites = await this.readJsonFile<Record<string, Favorite>>(filePath) || {};
  favorites[key] = favorite;
  await this.writeJsonFile(filePath, favorites);
}
```

#### 2. 缓存数据存储

```typescript
// 通用缓存存储
async setCache(key: string, data: any, expireSeconds?: number): Promise<void> {
  const cacheData = {
    data,
    expireTime: expireSeconds ? Date.now() + expireSeconds * 1000 : null
  };
  
  // 按类型分目录存储
  const keyParts = key.split(':');
  const cacheType = keyParts[0] || 'default';
  const cacheDir = path.join(this.cacheDir, cacheType);
  const fileName = keyParts.slice(1).join('_') + '.json';
  const filePath = path.join(cacheDir, fileName);
  
  await this.writeJsonFile(filePath, cacheData);
}

async getCache(key: string): Promise<any | null> {
  const keyParts = key.split(':');
  const cacheType = keyParts[0] || 'default';
  const cacheDir = path.join(this.cacheDir, cacheType);
  const fileName = keyParts.slice(1).join('_') + '.json';
  const filePath = path.join(cacheDir, fileName);
  
  const cacheData = await this.readJsonFile<{data: any, expireTime: number | null}>(filePath);
  if (!cacheData) return null;
  
  // 检查过期时间
  if (cacheData.expireTime && Date.now() > cacheData.expireTime) {
    await fs.unlink(filePath).catch(() => {}); // 忽略删除错误
    return null;
  }
  
  return cacheData.data;
}
```

#### 3. 统计数据存储

```typescript
// 播放统计存储
async updatePlayStatistics(userName: string, source: string, id: string, watchTime: number): Promise<void> {
  const statsPath = path.join(this.statsDir, 'playstats.json');
  const stats = await this.readJsonFile<PlayStatsResult>(statsPath) || this.createEmptyStats();
  
  // 更新统计逻辑
  // ... 统计计算代码
  
  await this.writeJsonFile(statsPath, stats);
}
```

### 性能优化策略

#### 1. 内存缓存

```typescript
class FileSystemStorage implements IStorage {
  private memoryCache = new Map<string, { data: any, expireTime?: number }>();
  private cacheTimeout = 5 * 60 * 1000; // 5分钟

  private async getWithMemoryCache<T>(key: string, fetcher: () => Promise<T>): Promise<T> {
    // 检查内存缓存
    const cached = this.memoryCache.get(key);
    if (cached && (!cached.expireTime || Date.now() < cached.expireTime)) {
      return cached.data;
    }

    // 从文件读取
    const data = await fetcher();
    
    // 更新内存缓存
    this.memoryCache.set(key, { 
      data, 
      expireTime: Date.now() + this.cacheTimeout 
    });

    return data;
  }
}
```

#### 2. 批量操作优化

```typescript
// 批量读取用户数据
private async getUserDataBatch<T>(userName: string, files: string[]): Promise<Record<string, T>> {
  const userDir = this.getUserDir(userName);
  const results: Record<string, T> = {};
  
  await Promise.all(
    files.map(async (file) => {
      const filePath = path.join(userDir, file);
      const data = await this.readJsonFile<T>(filePath);
      if (data) {
        results[file.replace('.json', '')] = data;
      }
    })
  );
  
  return results;
}
```

#### 3. 文件压缩

```typescript
import { compress, decompress } from 'lz4-napi';

// 大文件压缩存储
private async writeCompressedJson(filePath: string, data: any): Promise<void> {
  const jsonString = JSON.stringify(data);
  const compressed = await compress(Buffer.from(jsonString));
  await fs.writeFile(filePath + '.lz4', compressed);
}

private async readCompressedJson(filePath: string): Promise<any | null> {
  try {
    const compressed = await fs.readFile(filePath + '.lz4');
    const decompressed = await decompress(compressed);
    return JSON.parse(decompressed.toString());
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      return null;
    }
    throw error;
  }
}
```

## 需要支持的具体接口

### 1. 核心存储接口

基于 `IStorage` 接口，文件系统存储需要实现以下方法：

#### 用户数据管理
```typescript
// 用户认证
registerUser(userName: string, password: string): Promise<void>
verifyUser(userName: string, password: string): Promise<boolean>
checkUserExist(userName: string): Promise<boolean>
changePassword(userName: string, newPassword: string): Promise<void>
deleteUser(userName: string): Promise<void>
getAllUsers(): Promise<string[]>

// 播放记录
getPlayRecord(userName: string, key: string): Promise<PlayRecord | null>
setPlayRecord(userName: string, key: string, record: PlayRecord): Promise<void>
getAllPlayRecords(userName: string): Promise<{ [key: string]: PlayRecord }>
deletePlayRecord(userName: string, key: string): Promise<void>

// 收藏管理
getFavorite(userName: string, key: string): Promise<Favorite | null>
setFavorite(userName: string, key: string, favorite: Favorite): Promise<void>
getAllFavorites(userName: string): Promise<{ [key: string]: Favorite }>
deleteFavorite(userName: string, key: string): Promise<void>

// 搜索历史
getSearchHistory(userName: string): Promise<string[]>
addSearchHistory(userName: string, keyword: string): Promise<void>
deleteSearchHistory(userName: string, keyword?: string): Promise<void>
```

#### 配置管理
```typescript
// 管理员配置
getAdminConfig(): Promise<AdminConfig | null>
setAdminConfig(config: AdminConfig): Promise<void>

// 跳过配置
getSkipConfig(userName: string, source: string, id: string): Promise<EpisodeSkipConfig | null>
setSkipConfig(userName: string, source: string, id: string, config: EpisodeSkipConfig): Promise<void>
deleteSkipConfig(userName: string, source: string, id: string): Promise<void>
getAllSkipConfigs(userName: string): Promise<{ [key: string]: EpisodeSkipConfig }>
```

#### 缓存管理
```typescript
getCache(key: string): Promise<any | null>
setCache(key: string, data: any, expireSeconds?: number): Promise<void>
deleteCache(key: string): Promise<void>
clearExpiredCache(prefix?: string): Promise<void>
```

#### 统计功能
```typescript
getPlayStats(): Promise<PlayStatsResult>
getUserPlayStat(userName: string): Promise<UserPlayStat>
getContentStats(limit?: number): Promise<ContentStat[]>
updatePlayStatistics(userName: string, source: string, id: string, watchTime: number): Promise<void>
updateUserLoginStats(userName: string, loginTime: number, isFirstLogin?: boolean): Promise<void>
```

### 2. 扩展接口

#### 数据备份与恢复
```typescript
// 数据导出
async exportUserData(userName: string): Promise<Buffer>
async exportAllData(): Promise<Buffer>

// 数据导入
async importUserData(userName: string, data: Buffer): Promise<void>
async importAllData(data: Buffer): Promise<void>

// 数据清理
async clearUserData(userName: string): Promise<void>
async clearExpiredCache(): Promise<void>
```

#### 存储健康检查
```typescript
// 存储状态检查
async checkStorageHealth(): Promise<{
  available: boolean;
  totalSpace: number;
  usedSpace: number;
  freeSpace: number;
  errors: string[];
}>

// 数据完整性检查
async verifyDataIntegrity(): Promise<{
  valid: boolean;
  corruptedFiles: string[];
  missingFiles: string[];
}>
```

### 3. 配置接口

#### 环境变量配置
```bash
# 启用文件系统存储
NEXT_PUBLIC_STORAGE_TYPE=filesystem

# 数据存储目录（可选，默认 ./data）
FILE_SYSTEM_DATA_DIR=/path/to/data

# 缓存配置
FILE_SYSTEM_CACHE_SIZE=100MB
FILE_SYSTEM_CACHE_TTL=3600

# 压缩配置
FILE_SYSTEM_ENABLE_COMPRESSION=true
FILE_SYSTEM_COMPRESSION_THRESHOLD=10KB
```

#### 运行时配置
```typescript
interface FileSystemConfig {
  dataDir: string;
  cacheSize: number;
  cacheTTL: number;
  enableCompression: boolean;
  compressionThreshold: number;
  backupInterval: number;
  maxFileSize: number;
}
```

## 集成方案

### 1. 存储工厂扩展

```typescript
// src/lib/db.ts 修改
function createStorage(): IStorage {
  switch (STORAGE_TYPE) {
    case 'redis':
      return new RedisStorage();
    case 'upstash':
      return new UpstashRedisStorage();
    case 'kvrocks':
      return new KvrocksStorage();
    case 'filesystem':  // 新增
      return new FileSystemStorage();
    case 'localstorage':
    default:
      return null as unknown as IStorage;
  }
}
```

### 2. 依赖安装

```bash
# 文件系统操作增强
npm install --save lz4-napi chokidar

# TypeScript 类型
npm install --save-dev @types/node
```

### 3. 部署配置

#### Docker 部署
```dockerfile
# Dockerfile
FROM node:18-alpine

# 创建数据目录
RUN mkdir -p /app/data

# 设置环境变量
ENV FILE_SYSTEM_DATA_DIR=/app/data

# 数据卷映射
VOLUME ["/app/data"]
```

#### Vercel 部署限制

⚠️ **注意**：Vercel 无服务器环境不支持文件系统持久化，文件系统存储方案仅适用于：

- VPS/云服务器部署
- Docker 容器部署
- 本地开发环境

## 优势与限制

### 优势

1. **零配置** - 无需外部数据库服务
2. **数据可控** - 数据完全在本地存储
3. **成本低廉** - 无额外服务费用
4. **易于调试** - 数据文件可直接查看
5. **备份简单** - 直接复制数据目录
6. **离线可用** - 不依赖网络连接

### 限制

1. **单机限制** - 不支持多服务器共享
2. **并发限制** - 文件锁机制可能影响并发性能
3. **扩展性** - 大量用户时性能可能下降
4. **平台限制** - 不支持无服务器平台
5. **备份责任** - 需要手动备份和恢复

## 性能基准

### 预期性能指标

| 操作类型 | 预期响应时间 | 备注 |
|---------|-------------|------|
| 用户数据读取 | < 50ms | 内存缓存命中时 |
| 用户数据写入 | < 100ms | 小文件写入 |
| 缓存读取 | < 30ms | 内存缓存命中时 |
| 缓存写入 | < 80ms | 异步写入 |
| 统计查询 | < 200ms | 需要聚合计算时 |

### 性能优化建议

1. **内存缓存** - 热点数据内存缓存
2. **异步写入** - 非关键数据异步写入
3. **文件压缩** - 大文件压缩存储
4. **索引优化** - 建立适当的文件索引
5. **定期清理** - 自动清理过期缓存

## 监控与维护

### 日志记录

```typescript
class FileSystemStorage implements IStorage {
  private logOperation(operation: string, path: string, duration: number): void {
    console.log(`[FileSystem] ${operation}: ${path} (${duration}ms)`);
  }

  private logError(operation: string, path: string, error: Error): void {
    console.error(`[FileSystem] ${operation} failed: ${path}`, error);
  }
}
```

### 健康检查

```typescript
async checkStorageHealth(): Promise<StorageHealth> {
  try {
    const stats = await fs.stat(this.dataDir);
    const totalSpace = await this.getTotalDiskSpace();
    const freeSpace = await this.getFreeDiskSpace();
    
    return {
      available: true,
      totalSpace,
      usedSpace: totalSpace - freeSpace,
      freeSpace,
      errors: []
    };
  } catch (error) {
    return {
      available: false,
      totalSpace: 0,
      usedSpace: 0,
      freeSpace: 0,
      errors: [error.message]
    };
  }
}
```

### 自动备份

```typescript
class FileSystemStorage implements IStorage {
  private startBackupScheduler(): void {
    setInterval(async () => {
      try {
        await this.createBackup();
        console.log('[FileSystem] 自动备份完成');
      } catch (error) {
        console.error('[FileSystem] 自动备份失败:', error);
      }
    }, 24 * 60 * 60 * 1000); // 每24小时备份一次
  }
}
```

## 总结

文件系统存储方案为 LunaTV 提供了一种轻量级、零配置的持久化存储选择。该方案：

1. **技术可行** - 完全兼容现有架构
2. **实现简单** - 基于标准 Node.js 文件操作
3. **性能良好** - 适合中小规模部署
4. **易于维护** - 数据直观，备份简单

该方案特别适合：
- 个人或小团队部署
- 本地开发环境
- 数据敏感、需要完全控制的场景
- 无法使用外部数据库的限制环境

通过合理的性能优化和监控机制，文件系统存储方案可以很好地补充现有的存储选项，为用户提供更多的部署选择。